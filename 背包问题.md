# labuladong-python3

### 01背包问题
```
def knapsack(W, N, wt, val):
    # vector 全填入 0，base case 已初始化
    dp = [[0]*(W+1) for _ in range(N+1)]
    for i in range(1, N+1):
        for w in range(1, W+1):
            # 当前背包容量装不下，只能选择不装入背包
            if w - wt[i-1] < 0:
                dp[i][w] = dp[i-1][w]
            # 装入或者不装入背包，择优
            else:
                dp[i][w] = max(
                    dp[i-1][w],
                    dp[i-1][w-wt[i-1]]+val[i-1]
                    )
    return dp[N][W]
```

### 416. 分割等和子集
```
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        s = sum(nums)
        # 和为奇数时 不可能划分成两个和相等的集合
        if s % 2 != 0:
            return False
        n = len(nums)
        s = s // 2
        # base case
        # dp[..][0] = true和dp[0][..] = false，因为背包没有空间的时候，就相当于装满了，
        # 而当没有物品可选择的时候，肯定没办法装满背包
        dp = [[False]*(s+1) for _ in range(n+1)]
        for i in range(n+1):
            dp[i][0] = True
        for i in range(1,n+1):
            for j in range(1,s+1):
                if j - nums[i-1] < 0:
                    # 背包容量不足 不能装入第i个物品
                    dp[i][j] = dp[i-1][j]
                else:
                    # 装入或不装入背包
                    dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]
        return dp[n][s]
```
